#!/usr/bin/env node

const argv = require('yargs').argv;
const fs = require('fs');
const puppeteer = require('puppeteer');
const URL = require('url').URL;
const EventEmitter = require('events');
const os = require('os');
const sleep = require('util').promisify(setTimeout);

const PAGE_OPTIONS = {
  timeout: 30000,
  waitUntil: 'networkidle2',
};

const DEFAULT_ARGS = [
  '--disable-setuid-sandbox',
  '--no-sandbox',
  '--blink-settings=imagesEnabled=false',
  '--proxy-bypass-list=browser.sentry-cdn.com;sentry.io',
];

const BLOCKED_RESOURCE_TYPES = [
  'image',
  'media',
  'font',
  'texttrack',
  'object',
  'beacon',
  'imageset',
];

const SKIPPED_RESOURCES = [
  'quantserve',
  'adzerk',
  'doubleclick',
  'adition',
  'exelator',
  'sharethrough',
  'cdn.api.twitter',
  'google-analytics',
  'googletagmanager',
  'google',
  'fontawesome',
  'facebook',
  'analytics',
  'optimizely',
  'clicktale',
  'mixpanel',
  'zedo',
  'clicksor',
  'tiqcdn',
  // queue currently infinitely spins due to bugs
  // GOOD JOB HUMANS
  '/manage/queue/',
];

// Ported from http://en.cppreference.com/w/cpp/algorithm/lower_bound
function lowerBound(array, value, comp) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = (count / 2) | 0;
    let it = first + step;
    if (comp(array[it], value) <= 0) {
      it += 1;
      first = it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

class SessionCache {
  init() {
    this._storage = new Map();
    return Promise.resolve();
  }

  clear() {
    if (this._storage) {
      this._storage.clear();
    }
    return Promise.resolve();
  }

  close() {
    return Promise.resolve();
  }

  get(key) {
    return Promise.resolve(this._storage.get(key) || null);
  }

  set(key, value) {
    this._storage.set(key, value);
    return Promise.resolve();
  }

  enqueue(key, value, priority) {
    const queue = this._storage.get(key) || [];
    const item = {value, priority};
    if (queue.length && queue[queue.length - 1].priority >= priority) {
      queue.push(item);
      this._storage.set(key, queue);
      return Promise.resolve();
    }
    const index = lowerBound(queue, item, (a, b) => b.priority - a.priority);
    queue.splice(index, 0, item);
    this._storage.set(key, queue);
    return Promise.resolve();
  }

  dequeue(key) {
    const queue = this._storage.get(key) || [];
    this._storage.set(key, queue);
    const item = queue.shift();
    if (!item) return Promise.resolve(null);
    return Promise.resolve(item.value);
  }

  size(key) {
    const queue = this._storage.get(key);
    if (!queue) return Promise.resolve(0);
    return Promise.resolve(queue.length);
  }

  remove(key) {
    this._storage.delete(key);
    return Promise.resolve();
  }
}

const KEY = 'queue';
const INTERVAL = 200;

class PriorityQueue extends EventEmitter {
  constructor(options) {
    super();
    this._cache = options.cache;
    this._maxConcurrency = options.maxConcurrency || Infinity;
    this._isPaused = false;
    this._pendingCount = 0;
    this._resolveIdle = () => {};
  }

  init() {
    this._watch();
  }

  end() {
    this._unwatch();
  }

  async push(...args) {
    const priority = args.pop();
    await this._cache.enqueue(KEY, args, priority);
    this._pull();
  }

  pause() {
    this._isPaused = true;
    this._unwatch();
    this._resolveIdle();
  }

  resume() {
    if (!this._isPaused) return;
    this._isPaused = false;
    this._watch();
    this._pull();
  }

  isPaused() {
    return this._isPaused;
  }

  pending() {
    return this._pendingCount;
  }

  size() {
    return this._cache.size(KEY);
  }

  onIdle() {
    return new Promise(resolve => {
      this._resolveIdle = resolve;
    });
  }

  emitAsync(event, ...args) {
    const promises = [];
    this.listeners(event).forEach(listener => {
      promises.push(listener(...args));
    });
    return Promise.all(promises);
  }

  async _pull() {
    if (this._isPaused) return;
    if (this._pendingCount >= this._maxConcurrency) return;
    this._pendingCount += 1;
    const args = await this._cache.dequeue(KEY);
    if (!args) {
      this._pendingCount -= 1;
      if (this._pendingCount === 0) this._resolveIdle();
      return;
    }
    await this.emitAsync('pull', ...args);
    this._pendingCount -= 1;
    this._pull();
  }

  _watch() {
    this._unwatch();
    this._interval = setInterval(() => {
      this._pull();
    }, INTERVAL);
  }

  _unwatch() {
    clearInterval(this._interval);
  }
}

class Crawler {
  constructor(options) {
    this.userAgent =
      options.userAgent ||
      'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3239.108 Safari/537.36';
    this.domains = options.domains ? new Set(options.domains) : null;
    this.screenshots = options.screenshots || null;
    this.proxy = options.proxy || null;
    this.headless = options.headless !== false;

    this._browser = null;
    this._errors = [];
    this._cache = new SessionCache();
    this._queue = new PriorityQueue({
      cache: this._cache,
      maxConcurrency: options.maxConcurrency || 5,
    });
    this._count = 0;
    this._visited = new Set();
    this._queue.on('pull', (_options, previousUrl) =>
      this._request(_options, previousUrl)
    );
    this._formConfigs = options.formConfigs || [];
  }

  async init() {
    await this._cache.init();
    this._queue.init();
  }

  async getBrowser() {
    if (this._browser) return this._browser;
    let args = [...DEFAULT_ARGS];
    if (this.proxy) {
      args.push(`--proxy-server=${this.proxy}`);
    }
    this._browser = await puppeteer.launch({
      args: args,
      headless: this.headless,
      ignoreHTTPSErrors: true,
    });
    return this._browser;
  }

  async close() {
    this._queue.end();
    await this._cache.clear();
    await this._cache.close();
    if (!this._browser) return;
    await this._browser.close();
    this._browser = null;
  }

  async queue(url, options = {}) {
    this._visited.add(url);
    this._queue.push(url, options, 0);
  }

  async _processPage(page, initialUrl) {
    // ideally at this point we'd invalidate visited links *if* cookies
    // have changed

    const url = initialUrl || page.url();

    if (this.screenshots) {
      let fileName = new URL(url).pathname.replace(/(\.|\/|:|%|#)/g, '_');
      if (fileName.length > 100) {
        fileName = fileName.substring(0, 100);
      }
      await page.screenshot({
        path: `${this.screenshots}/${fileName}.jpeg`,
        fullPage: true,
      });
    }

    await this._discoverLinks(page);

    const formData = this._formConfigs.find(x => url.match(x.url));
    if (formData) {
      console.info('  -> Doing the human thing with form data');
      await Promise.all(
        Object.keys(formData.fields).map(fieldName => {
          page.$eval(
            fieldName,
            (el, fieldValue) => (el.value = fieldValue),
            formData.fields[fieldName]
          );
        })
      );
      // https://github.com/GoogleChrome/puppeteer/issues/1412
      page.click(formData.submitElement);
      await page.waitForNavigation({...PAGE_OPTIONS});
      this._count += 1;
      console.log(`${this._count}. ${page.url()}`);
      await this._processPage(page);
    }
  }

  async _request(url, options) {
    const browser = await this.getBrowser();
    const page = await browser.newPage();
    await page.setRequestInterception(true);
    await page.setUserAgent(this.userAgent);

    page.on('request', request => {
      const requestUrl = request._url.split('?')[0].split('#')[0];
      if (this._isSentryResource(requestUrl)) {
        request.continue();
      } else if (
        BLOCKED_RESOURCE_TYPES.indexOf(request.resourceType()) !== -1 ||
        SKIPPED_RESOURCES.some(r => requestUrl.indexOf(r) !== -1)
      ) {
        request.abort();
      } else if (!this._isDomainAllowed(new URL(requestUrl).host)) {
        request.abort();
      } else {
        request.continue();
      }
    });

    try {
      this._count += 1;
      console.log(`${this._count}. ${url}`);
      await page.goto(url, {...PAGE_OPTIONS});
      await this._processPage(page, url);
    } catch (err) {
      await sleep(3000000);
      // TODO(dcramer): if this throws a ERR_PROXY_CONNECTION_FAILED error we need to abort
      this._errors.push([url, err]);
      console.error(`An error occured on url: ${url}`, err);
    } finally {
      await page.close();
    }
  }

  async onIdle() {
    await this._queue.onIdle();
  }

  errors() {
    return this._errors;
  }

  hasErrors() {
    return !!this._errors.length;
  }

  async _discoverLinks(page) {
    const links = await page.$$eval('a', nodes => nodes.map(n => n.href));
    links.forEach(link => {
      if (!link) return;
      link = link.split('#')[0];
      const linkDomain = new URL(link).host;
      if (
        this._isDomainAllowed(linkDomain) &&
        !this._visited.has(link) &&
        !SKIPPED_RESOURCES.some(r => link.indexOf(r) !== -1)
      ) {
        this.queue(link);
      }
    });
  }

  _isSentryResource(url) {
    if (url.indexOf('https://browser.sentry-cdn.com') === 0) return true;
    if (url.indexOf('https://sentry.io/api/') === 0) return true;
    return false;
  }

  _isDomainAllowed(domain) {
    if (!this.domains) return true;
    return this.domains.has(domain);
  }
}

class Proxy {
  constructor(options) {
    this.url = options.url;
    this.dsn = options.dsn;
    this.buildId = options.buildId;
    this.port = options.port || 8063;
    this.sentryVersion = options.sentryVersion || '5.4.3';

    this._process = null;
  }

  async init() {
    this._server = await this.makeProxy();
    this._server.onError((ctx, err, errorKind) => {
      var url = ctx && ctx.clientToProxyRequest ? ctx.clientToProxyRequest.url : '';
      console.error(errorKind + ' on ' + url + ':', err);
    });

    this._server.onRequest((ctx, callback) => {
      console.log(ctx.clientToProxyRequest.headers.host, new URL(this.url).host);
      if (ctx.clientToProxyRequest.headers.host == new URL(this.url).host) {
        ctx.onResponseData((ctx, chunk, callback) => {
          console.log(
            chunk.toString().replace(/(<body[^>]+)>/g, `$1${this.getSentryBinding()}`)
          );
          chunk = new Buffer(
            chunk.toString().replace(/(<body[^>]+)>/g, `$1${this.getSentryBinding()}`)
          );
          // console.log(chunk.toString());
          return callback(null, chunk);
        });
      }
      return callback();
    });
  }

  async close() {
    if (this._server) {
      this._server.close();
      this._server = null;
    }
  }

  async makeProxy() {
    const Proxy = require('http-mitm-proxy');
    const {promisify} = require('util');
    const {exec} = require('child_process');

    const execPromise = promisify(exec);

    // LINUX
    // const nssDbPath = os.homedir() + '/.pki/nssdb';
    // try {
    //   fs.statSync(nssDbPath);
    // } catch (err) {
    //   fs.mkdirSync(nssDbPath, {recursive: true});
    //   await execPromise('certutil -d sql:$HOME/.pki/nssdb -N --empty-password');
    // }

    const proxy = Proxy();
    proxy.use(Proxy.wildcard);
    proxy.use(Proxy.gunzip);
    return new Promise((resolve, reject) => {
      proxy.listen({port: this.port, silent: !this.debug}, async err => {
        if (err) return reject(err);
        // Add CA certificate to chromium and return initialize proxy object
        await execPromise(
          'openssl x509 -outform der -in ./.http-mitm-proxy/certs/ca.pem -out ./.http-mitm-proxy/certs/ca.crt'
        );
        await execPromise(
          'security add-certificate ./.http-mitm-proxy/certs/ca.crt || exit 0'
        );
        // await execPromise(
        //   'security add-trusted-cert ./.http-mitm-proxy/certs/ca.crt || exit 0'
        // );
        resolve(proxy);
        // LINUX
        // execPromise(
        //   'certutil -d sql:$HOME/.pki/nssdb -A -t "C,," -n mitm-ca -i ./.http-mitm-proxy/certs/ca.pem'
        // )
        //   .then(() => resolve(proxy))
        //   .catch(reject);
      });
    });
  }

  getSentryBinding() {
    return `
<script src="https://browser.sentry-cdn.com/${
      this.sentryVersion
    }/bundle.min.js" crossorigin="anonymous"></script>
<script>
Sentry.init({
  dsn: ${JSON.stringify(this.dsn)},
  environment: 'test'
});
Sentry.configureScope(function(scope) {
  scope.setContext("build", {
    id: ${JSON.stringify(this.buildId)}
  });
});
</script>
`;
  }

  address() {
    return `localhost:${this.port}`;
  }
}

(async () => {
  const initialUrl = new URL(argv.url);
  const screenshots = './.artifacts/screenshots';

  try {
    fs.statSync(screenshots);
  } catch (err) {
    fs.mkdirSync(screenshots, {recursive: true});
  }

  const maxConcurrency = argv.concurrency || os.cpus().length - 1;
  const allowedDomains = [initialUrl.host];

  const proxy = new Proxy({
    url: argv.url,
    dsn: argv.dsn,
    buildId: argv.buildId,
    debug: argv.debug,
  });

  const crawler = new Crawler({
    domains: allowedDomains,
    proxy: proxy.address(),
    maxConcurrency,
    screenshots,
    headless: !argv.debug,
    formConfigs: [
      {
        url: /\/auth\/login\/([^\/]+\/)?$/i,
        fields: {
          '#id_username': argv.username,
          '#id_password': argv.password,
        },
        submitElement: 'button[type=submit]',
      },
    ],
  });

  try {
    console.log('Automating Humans...');
    console.log(`-> screenshots: ${screenshots}`);
    console.log(`-> maxConcurrency: ${maxConcurrency}`);
    console.log(`-> initialUrl: ${argv.url}`);
    console.log(`-> allowedDomains: ${allowedDomains}`);
    console.log(`-> proxy: ${proxy.address()}`);
    console.log('');

    await proxy.init();
    await crawler.init();
    await crawler.queue(argv.url);
    await crawler.onIdle();
    await crawler.close();
  } finally {
    await proxy.close();
    await crawler.close();
  }
  const errors = crawler.errors();
  if (errors.length) {
    console.error(`There were ${errors.length} error(s) encountered:`);
    errors.forEach(([url, error]) => {
      console.error(`  ${url}: ${error}`);
    });
    process.exit(1);
  }
})().catch(err => {
  console.error(err);
  process.exit(1);
});
